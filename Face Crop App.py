# -*- coding: utf-8 -*-
"""Face Crop App.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G9vTMtXBt6CBiFyt6j_Ktv7pRqXfa5yI
"""

!git clone https://github.com/fizyr/keras-retinanet.git

# Commented out IPython magic to ensure Python compatibility.
# %cd keras-retinanet/
!pip install .

!python setup.py build_ext --inplace

import numpy as np
import matplotlib.pyplot as plt
import requests
import urllib
import os
import pandas as pd
from PIL import Image

from keras_retinanet import models
from keras_retinanet.utils.image import preprocess_image, resize_image
from keras_retinanet.utils.visualization import draw_box, draw_caption
from keras_retinanet.utils.colors import label_color
!ls keras-retinanet

ann = pd.read_csv("/content/drive/My Drive/Colab Notebooks/Annotate.csv", names=["image_name","x_min","y_min","x_max", "y_max","class_name"])
ann.head()

def show_image_with_boxes(df):
  # pick a random image
  filepath = df.sample()['image_name'].values[0]

  # get all rows for this image
  df2 = df[df['image_name'] == filepath]
  im = np.array(Image.open(filepath))

  # if there's a PNG it will have alpha channel
  im = im[:,:,:3]

  for idx, row in df2.iterrows():
    d_class = row["class_name"]
    box = [
      row['x_min'],
      row['y_min'],
      row['x_max'],
      row['y_max'],
    ]
    print(box)
    
    draw_box(im, box, color=(255, 0, 0))
    caption = "{}".format(d_class)
    draw_caption(im, box, caption)

  plt.axis('off')
  plt.imshow(im)
  plt.show()

plt.rcParams['figure.figsize'] = [20, 10]

show_image_with_boxes(ann)

ann.to_csv('annotation.csv', index=False, header=None)

classes = ['face']
with open('classes.csv', 'w') as f:
    for i, class_name in enumerate(classes):
        f.write(f'{class_name},{i}\n')

!head classes.csv

!head annotation.csv

if not os.path.exists('snapshots'):
  os.mkdir('snapshots')

PRETRAINED_MODEL = 'snapshots/_pretrained_model.h5'
URL_MODEL = 'https://github.com/fizyr/keras-retinanet/releases/download/0.5.1/resnet50_coco_best_v2.1.0.h5'
urllib.request.urlretrieve(URL_MODEL, PRETRAINED_MODEL)

print('Downloaded pretrained model to ' + PRETRAINED_MODEL)

!ls keras-retinanet

!keras-retinanet/keras_retinanet/bin/train.py --freeze-backbone \
  --random-transform \
  --weights {PRETRAINED_MODEL} \
  --batch-size 8 \
  --steps 500 \
  --epochs 10 \
  csv annotation.csv classes.csv

!ls snapshots

from glob import glob
model_paths = glob('snapshots/resnet50_csv_*.h5')
latest_path = sorted(model_paths)[-1]
print("path:", latest_path)

model = models.load_model(latest_path, backbone_name='resnet50')
model = models.convert_model(model)

label_map = {}
for line in open('classes.csv'):
  row = line.rstrip().split(',')
  label_map[int(row[1])] = row[0]

def show_image_with_predictions(df, threshold=0.5):
  # choose a random image
  row = df.sample()
  filepath = row['image_name'].values[0]
  print("filepath:", filepath)

  # get all rows for this image
  df2 = df[df['image_name'] == filepath]
  im = np.array(Image.open(filepath))
  print("im.shape:", im.shape)

  # if there's a PNG it will have alpha channel
  im = im[:,:,:3]

  # plot true boxes
  for idx, row in df2.iterrows():
    box = [
      row['x_min'],
      row['y_min'],
      row['x_max'],
      row['y_max'],
    ]
    #print(box)
    #draw_box(im, box, color=(255, 0, 0))
  
  ### plot predictions ###

  # get predictions
  imp = preprocess_image(im)
  imp, scale = resize_image(im)

  boxes, scores, labels = model.predict_on_batch(
    np.expand_dims(imp, axis=0)
  )

  # standardize box coordinates
  boxes /= scale

  # loop through each prediction for the input image
  for box, score, label in zip(boxes[0], scores[0], labels[0]):
    # scores are sorted so we can quit as soon
    # as we see a score below threshold
    if score < threshold:
      break

    box = box.astype(np.int32)
    color = label_color(label)
    draw_box(im, box, color=color)

    class_name = label_map[label]
    caption = f"{class_name} {score:.2f}"
    draw_caption(im, box, caption)

  plt.axis('off')
  plt.imshow(im)
  plt.show()

show_image_with_predictions(ann, threshold=0.4)

def show_image_with_predictionss(filepath, threshold=0.5):
  
  im = np.array(Image.open(filepath))
  print("im.shape:", im.shape)

  # if there's a PNG it will have alpha channel
  im = im[:,:,:3]

 
  
  ### plot predictions ###

  # get predictions
  imp = preprocess_image(im)
  imp, scale = resize_image(im)

  boxes, scores, labels = model.predict_on_batch(
    np.expand_dims(imp, axis=0)
  )

  # standardize box coordinates
  boxes /= scale

  # loop through each prediction for the input image
  for box, score, label in zip(boxes[0], scores[0], labels[0]):
    # scores are sorted so we can quit as soon
    # as we see a score below threshold
    if score < threshold:
      break

    box = box.astype(np.int32)
    color = label_color(label)
    draw_box(im, box, color=color)

    class_name = label_map[label]
    caption = f"{class_name} {score:.2f}"
    draw_caption(im, box, caption)

  plt.axis('off')
  plt.imshow(im)
  plt.show()

!wget https://images.bewakoof.com/t540/last-man-standing-full-sleeve-t-shirt-men-s-printed-full-sleeve-t-shirt-266587-1586317114.jpg

!wget https://image.shutterstock.com/image-photo/collage-portraits-ethnically-diverse-mixed-260nw-725291137.jpg

show_image_with_predictionss('collage-portraits-ethnically-diverse-mixed-260nw-725291137.jpg' , threshold=0.49)

show_image_with_predictionss('last-man-standing-full-sleeve-t-shirt-men-s-printed-full-sleeve-t-shirt-266587-1586317114.jpg' , threshold=0.49)

